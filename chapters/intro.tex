\chapter{Introduction}

Programming has come a very long way from writing basic binary instructions. Over time, the emergence of different programming languages has widened the availability and range of applications of possible software projects. One of the most critical advances provided by newer programming languages is the level of abstraction they offer. Different features of programming languages, such as data types and garbage collection, have helped programmers move past machine-specific details to focus on more complex problems. Although software development has made significant advances over the past several decades, improved performance continues to be one of the chief concerns of both software producers and consumers. Principal concerns regarding performance include program speed and efficient resource usage, such as memory and I/O devices, and are inherent to all programming languages regardless of abstraction level.

Today, large software projects can be expected to contain at least millions of lines of code\cite{google}, written by different developers in relatively isolated settings. Such large codebases provide numerous opportunities for software optimization; although individual developers can attempt to optimize certain sections of the software by hand, this approach is infeasible on a larger scale. Additionally, software development often makes tradeoffs between performance and readability; for certain software teams, code readability may be more useful in some situations than pure efficiency. Thus, the only practical approach for optimizing such large programs is through an automated process, such as an optimization pass through a compiler. One such component of software optimization is alias analysis, which attempts to determine which variables in a program refer to the same area in memory; this is used to move instructions in a way that improve performance without interfering with program execution.

Several alias analyses have been proposed over the past few decades, having varying degrees of precision and time and space complexity. However, few studies have been conducted to compare these techniques with one another, nor to measure with program data to confirm their accuracy. Normally, this is out of the scope of alias analyses because these processes are static, and can only rely upon the input source code. This thesis addresses the limitations of previous studies by examining data from several benchmarks and comparing this data to commonly used alias analyses to objectively measure their accuracy. Additionally, we also gather additional program statistics to further determine which programs are the most suitable for evaluating subsequent alias analysis techniques.
