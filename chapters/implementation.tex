\chapter{Implementation}

\section{LLVM Instrumentation}
To measure the effectiveness of various alias analyses, we instrument a series of C programs to obtain data about which memory addresses are accessed. We perform this instrumentation on LLVM source files translated from the original C source code to have finer granularity of instrumentation; even without explicit pointer operations or variable assignment, individual expressions or statements may contain multiple memory accesses that are not easily captured at the level of the target language. At the LLVM level, pointer values are also stored within virtual registers alongside variables, providing additional aliases to quantify. For program instrumentation, we are primarily concerned with three types of instructions: load, store, and getelementptr. For these instructions, we output the referenced memory address, along with additional information that we use to find the original virtual registers within the corresponding LLVM file.

\subsection{load instructions}
The second operand of a load instruction is the pointer where the desired value is stored; load instructions are generated for all variable references in the input program, along with other pointer operations. This operand can be a global or local variable pointer, or another virtual register. Whenever a load instruction is found, its pointer operand is printed as a hexadecimal value to standard output. Because virtual registers only exist at compilation time in the LLVM file, the instrumented code also outputs the file name and the line number of the corresponding load instruction. This information is used to map the original operand to the actual pointer values retrieved from running the instrumented code.

\subsection{store instructions}
The second operand of a store instruction is the pointer of the value to be updated. As expected, store instructions are generated from variable assignments in the input program, since these statements update values that are stored in memory. As with load instructions, whenever a store instruction is encountered, the instrumented program prints the memory address, file name, and line number of that instruction to standard output. Only this information is necessary for instrumentation, as alias analysis does not distinguish between loads from and stores to memory addresses.

\subsection{getelementptr instructions}
The getelementptr instruction is used to compute pointers for specific fields contained within a structure, and elements of an array. When structure field references are converted from C to LLVM, the field names are converted to integer offsets based on the order of the fields within the corresponding struct type declaration; the result of the getelementptr instruction is subsequently used as part of a load or store instruction, depending on whether or not that structure field is being read from or written to. The first operand of the getelementptr instruction is the pointer to the original structure or array, and is instrumented in the same way as the load and store instructions; this distinction is made to measure memory accesses to compound types, compared to loads and stores from single variables. This consists of printing the base memory address, file name, and line number to standard output. The computed memory address is not included, as it is instrumented in later memory access instructions that reference it.

\subsection{memory allocation instructions}
To gather data on the sizes and lifetimes of dynamically allocated memory, we instrument calls to malloc, realloc, and free. For calls to malloc and realloc, the instrumented code prints the return value of the call as a memory address, along with the file name, line number, size, and timestamp to standard output; we chose to omit instrumenting calls to calloc, as they were not present in a majority of our examined programs in any meaningful frequency. Because dynamic memory can be allocated and freed within a short period of time, often less than a second, the timestamps are taken from calls to the C standard library function clock. Whenever a call to free allocated memory is found within the program, the instrumented code prints the passed in memory address, the file name, the line number, and the timestamp.

\subsection{Non-exhaustive instrumentation}
When instrumenting the LLVM files, we are primarily concerned with pointer operands that are either variables or virtual registers; alias analyses at the LLVM level tend to focus on such operands as well. However, depending on the generated LLVM IR, some irregular operands are also instrumented. Such operands include, but are not limited to, nested getelementptr instructions, vectorized pointer types, and temporary structure types. While the program instrumentation does account for some of these operands as pointers identified within the program, due to the somewhat flexible nature of the IR, the instrumentation is not exhaustive in identifying such operands; any irregular operands that are not detected are not representative of the operands we are concerned with.
